<?xml version="1.0" encoding="UTF-8"?>
<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
           http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint.xsd">

    <bean id="mysqlthedata" class="com.mysql.jdbc.jdbc2.optional.MysqlDataSource">
        <!--<property name="serverName" value="mysql-test.cniyuo94cdas.eu-west-1.rds.amazonaws.com"/>-->
        <property name="url" value="jdbc:mysql://mysql-test.cniyuo94cdas.eu-west-1.rds.amazonaws.com:3306/thedata"/>
        <property name="user" value="admocp"/>
        <property name="password" value="##admocp" />
    </bean>

    <service ref="mysqlthedata" interface="javax.sql.DataSource">
        <service-properties>
            <entry key="osgi.jndi.service.name" value="jdbc/mysqlthedata"/>
        </service-properties>
    </service>

    <bean id="listAggregation" class="aggregationStrategy.ListAggregationStrategy"/>

    <camelContext id="atalayaEIP" xmlns="http://camel.apache.org/schema/blueprint" useMDCLogging="true">

        <propertyPlaceholder id="properties"
                             location="classpath:etc/uri.properties"
                             xmlns="http://camel.apache.org/schema/blueprint" />

        <streamCaching id="CacheConfig" bufferSize="100024000"
                       spoolThreshold="100024000" />

        <threadPoolProfile id="concurrentProfile" poolSize="50" maxPoolSize="80" maxQueueSize="-1"/>

        <dataFormats>
            <json id="json" library="Jackson" unmarshalTypeName="java.util.Map"/>
        </dataFormats>

        <restConfiguration apiContextListing="true"
                           apiContextPath="api-docs" bindingMode="off" component="netty4-http"
                           contextPath="big" enableCORS="true" host="0.0.0.0" port="8282">

            <endpointProperty key="chunkedMaxContentLength" value="10444800"/>
            <dataFormatProperty key="prettyPrint" value="true" />

            <apiProperty key="base.path" value="rest" />
            <apiProperty key="api.version" value="0.0.1" />
            <apiProperty key="api.title" value="Data Integration Platform" />
            <apiProperty key="api.description" value="Data Integration API" />
            <apiProperty key="api.contact.name" value="Atalaya Consulting" />
            <apiProperty key="cors" value="true" />
        </restConfiguration>

        <rest path="/1.0" produces="application/json">
            <description>Data Integration API</description>
            <get uri="/runsql/{datasourceName}">
                <description>check tables</description>
                <responseMessage code="200" message="Ok" />
                <responseMessage code="404" message="Error, no hi ha taules" />
                <route id="getTablesT100">
                    <toD uri="sql:${body}?dataSourceRef=${headers.datasourceName}"/>
                </route>
            </get>
            <put uri="/runsql/{datasourceName}">
                <description>create tables</description>
                <responseMessage code="200" message="Ok" />
                <responseMessage code="404" message="Error, No s'han pogut crear les taules" />
                <route id="createTablesT100">
                    <toD uri="sql:${body}?dataSourceRef=${headers.datasourceName}"/>
                </route>
            </put>
            <delete uri="/runsql/{datasourceName}" produces="application/json">
                <description>delete tables</description>
                <responseMessage code="200" message="Ok" />
                <responseMessage code="404" message="Error, No s'han pogut eliminar les taules" />
                <route id="dropTablesT100">
                    <toD uri="sql:${body}?dataSourceRef=${headers.datasourceName}"/>
                </route>
            </delete>
            <post uri="/transfer/{datasourceName}" produces="application/json">
                <description>load data</description>
                <responseMessage code="200" message="Ok" />
                <responseMessage code="404" message="Error, No s'han pogut insertar les dades" />
                <route id="loadData" streamCache="true">
                    <log message="${date:now:yyyy-MM-dd'T'HH:mm:ss:SSS}: Start Loading data into Database"/>
                    <unmarshal>
                        <csv skipHeaderRecord="true" useOrderedMaps="true" delimiter="|"/>
                    </unmarshal>
                    <!--<toD uri="dataformat:csv:marshal?delimiter=${header.FIELD_DELIMITER}"/>-->
                    <to uri="{{csvMQ}}"/>
                </route>
            </post>
        </rest>

        <route autoStartup="true" id="bulkInsert" streamCache="true">
            <from uri="{{csvMQ}}"/>
            <transacted/>
            <validate>
                <simple>${body} is 'java.util.ArrayList'</simple>
            </validate>
            <threads poolSize="10">
                <split streaming="true" parallelProcessing="true" strategyRef="listAggregation">
                    <simple>${body}</simple>
                    <aggregate strategyRef="listAggregation" completionSize="100" completionTimeout="1000" parallelProcessing="true">
                        <correlationExpression>
                            <constant>true</constant>
                        </correlationExpression>
                        <toD uri="sql:${headers.insertSQL}?batch=true&amp;dataSourceRef=${headers.datasourceName}"/>
                    </aggregate>
                </split>
            </threads>
        </route>

    </camelContext>

    <!-- define the activemq Camel component so we can integrate with the AMQ broker -->
    <bean id="activemq" class="org.apache.activemq.camel.component.ActiveMQComponent">
        <!-- due to a bug in activemq-camel we must configure using a nested configuration bean -->
        <property name="configuration">
            <bean class="org.apache.camel.component.jms.JmsConfiguration">
                <property name="connectionFactory" ref="jmsXaPoolConnectionFactory"/>
                <!-- JTA transaction manager (Spring interface to Aries-TM) -->
                <property name="transactionManager" ref="springJtaTxManager"/>
                <!-- IMPORTANT: We set local transactions to false, because the JtaTransactionManager
                     will take care of enrolling the XA JMS Connection when needed. -->
                <property name="transacted" value="false"/>
                <!-- IMPORTANT: and disable cache level as the JtaTransactionManager needs to control the consumers
                     from its JcaPooledConnectionFactory -->
                <property name="cacheLevelName" value="CACHE_NONE"/>
            </bean>
        </property>
    </bean>

    <!-- plain javax.transaction.TransactionManager is not enough to do recovery for ActiveMQ -->
    <reference id="jtaTxManager" interface="org.apache.geronimo.transaction.manager.RecoverableTransactionManager"/>
    <!-- aries-transaction-manager registers this interface if it finds the org.springframework.transaction.PlatformTransactionManager class -->
    <reference id="springJtaTxManager" interface="org.springframework.transaction.PlatformTransactionManager"/>

    <!-- the ConnectionFactory to connect to the JMS broker -->
    <bean id="activeMqXaConnectionFactory" class="org.apache.activemq.ActiveMQXAConnectionFactory">
        <!-- connection to the remote ActiveMQ broker -->
        <property name="brokerURL" value="tcp://localhost:61616"/>
    </bean>

    <!-- pool the connection factory so it runs faster -->
    <!-- and use JCA so it works with JTA/XA -->
    <bean id="jmsXaPoolConnectionFactory" class="org.apache.activemq.pool.JcaPooledConnectionFactory">
        <property name="name" value="activemq.default"/>
        <property name="maxConnections" value="8"/>
        <property name="transactionManager" ref="jtaTxManager"/>
        <property name="connectionFactory" ref="activeMqXaConnectionFactory"/>
    </bean>

    <!-- A ResourceManager is needed for every transactional resource in order to
         recover any outstanding transactions after a crash.
         It will register with the Aries transaction manager, which then calls
         recoverResource() on the transactional resource itself. -->
    <bean id="resourceManager" class="org.apache.activemq.jms.pool.GenericResourceManager" init-method="recoverResource">
        <property name="transactionManager" ref="jtaTxManager"/>
        <property name="connectionFactory" ref="jmsXaPoolConnectionFactory"/>
        <property name="resourceName" value="activemq.default"/>
        <property name="userName" value="karaf"/>
        <property name="password" value="karaf"/>
    </bean>

</blueprint>